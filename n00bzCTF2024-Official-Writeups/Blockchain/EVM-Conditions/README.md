# EVM - Conditions | NoobMaster

- Description: So much maths... You need to find the value, in hex, that you need to send to make the contract STOP and not self destruct. Wrap the hex in n00bz{}. If the correct answer is 9999, the flag is `n00bz{0x270f}`. 

- evm.txt:/attachments/evm.txt

# Write-up

This is the second challenge in the EVM series. Doing the same thing as in the first one, the instructions are:
```
0x0: PUSH0 [0x0] <- Top of the stack
0x1: PUSH1 0x0f [0x0,0xf] <- Top of the stack
0x3: PUSH1 0x70 [0x0,0xf,0x70] <- Top of the stack
0x5: MUL [0x0,0x690] <- Top of the stack
0x6: PUSH2 0x0258 [0x0,0x690,0x258] <- Top of the stack
0x9: MSTORE [0x0] <- Top of the stack. Memory: [0x258:0x278->0x690]
0xa: PUSH0 [0x0,0x0] <- Top of the stack
0xb: PUSH1 0x05 [0x0,0x0,0x05] <- Top of the stack
0xd: PUSH1 0x96 [0x0,0x0,0x5,0x96] <- Top of the stack
0xf: DIV [0x0,0x0,0x1e] <- Top of the stack
0x10: PUSH1 0x90 [0x0,0x0,0x1e,0x90] <- Top of the stack
0x12: MSTORE [0x0,0x0] <- Top of the stack. Memory: [0x258:0x278->0x690,0x90:0xb0->0x1e]
0x13: PUSH0 [0x0,0x0,0x0] <- Top of the stack
0x14: PUSH1 0x07 [0x0,0x0,0x0,0x7] <- Top of the stack
0x16: PUSH1 0x09 [0x0,0x0,0x0,0x7,0x9] <- Top of the stack
0x18: EXP [0x0,0x0,0x0,0x48fb79] <- Top of the stack
0x19: PUSH2 0xfffa [0x0,0x0,0x0,0x48fb79,0xfffa] <- Top of the stack
0x1c: MSTORE [0x0,0x0,0x0] <- Top of the stack. Memory: [0x258:0x278->0x690,0x90:0xb0->0x1e,0xfffa:0x1001a->0x48fb79]
0x1d: PUSH2 0x539 [0x0,0x0,0x0,0x539] <- Top of the stack
0x20: PUSH2 0x26aa [0x0,0x0,0x0,0x539,0x26aa] <- Top of the stack
0x23: XOR [0x0,0x0,0x0,0x2393] <- Top of the stack
0x24: PUSH3 0x0bfabf [0x0,0x0,0x0,0x2393,0x0bfabf] <- Top of the stack
0x28: MSTORE [0x0,0x0,0x0] <- Top of the stack. Memory: [0x258:0x278->0x690,0x90:0xb0->0x1e,0xfffa:0x1001a->0x48fb79,0x0bfabf:0xbfadf->0x2393]
0x29: PUSH1 0x03 [0x0,0x0,0x0,0x3] <- Top of the stack
0x2b: PUSH2 0xfffa [0x0,0x0,0x0,0x3,0xfffa] <- Top of the stack
0x2e: MLOAD [0x0,0x0,0x0,0x3,0x48fb79] <- Top of the stack (basically loading data from a memory array)
0x2f: MUL [0x0,0x0,0x0,0xdaf26b] <- Top of the stack
0x30: PUSH3 0x0bfabf [0x0,0x0,0x0,0xdaf26b,0x0bfabf] <- Top of the stack
0x34: MLOAD [0x0,0x0,0x0,0xdaf26b,0x2393] <- Top of the stack
0x35: ADD [0x0,0x0,0x0,0xdb15fe] <- Top of the stack
0x36: CALLVALUE [0x0,0x0,0x0,0xdb15fe,msg.value] <- Top of the stack
0x37: PUSH2 0x0258 [0x0,0x0,0x0,0xdb15fe,msg.value,0x0258] <- Top of the stack
0x3a: MLOAD [0x0,0x0,0x0,0xdb15fe,msg.value,0x690] <- Top of the stack
0x3b: PUSH1 0x04 [0x0,0x0,0x0,0xdb15fe,msg.value,0x690,0x4] <- Top of the stack
0x3d: MUL [0x0,0x0,0x0,0xdb15fe,msg.value,0x1a40] <- Top of the stack
0x3e: ADD [0x0,0x0,0x0,0xdb15fe,msg.value+0x1a40] <- Top of the stack
0x3f: PUSH1 0x90 [0x0,0x0,0x0,0xdb15fe,msg.value+0x1a40,0x90] <- Top of the stack
0x41: MLOAD [0x0,0x0,0x0,0xdb15fe,msg.value+0x1a40,0x1e] <- Top of the stack
0x42: ADD [0x0,0x0,0x0,0xdb15fe,msg.value+0x1a40+0x1e] <- Top of the stack
0x43: EQ [0x0,0x0,0x0,0xdb15fe==msg.value+0x1a40+0x1e] <- Top of the stack
0x44: PUSH1 0x48 [0x0,0x0,0x0,0xdb15fe==msg.value+0x1a40,0x48] <- Top of the stack
0x46: JUMPI [0x0,0x0,0x0,0xdb15fe==msg.value+0x1a40,0x48] <- Top of the stack (Jump to the instruction at 0x48 if `0xdb15fe==msg.value+0x1a40`)
0x47: SELFDESTRUCT (We do not want to reach here)
0x48: STOP (This is where we want to reach. For that, we need to make JUMPI condition True.)
```
In order to make the `JUMPI` statement right, this should be True: `6750 + msg.value == 14358014`. Solve the equation, convert to hex, and wrap in n00bz{}

# Flag - n00bz{0xdafba0}
